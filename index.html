<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è–èª•è½åŠ›å¿è€… - è»Œé“ç‰ˆ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: 'Arial Black', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, #2c0e37 0%, #000000 100%);
            overflow: hidden;
        }

        .bg-pattern {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0.15;
            pointer-events: none;
            background-image: linear-gradient(45deg, #ffffff 25%, transparent 25%, transparent 75%, #ffffff 75%, #ffffff), 
                              linear-gradient(45deg, #ffffff 25%, transparent 25%, transparent 75%, #ffffff 75%, #ffffff);
            background-position: 0 0, 10px 10px;
            background-size: 20px 20px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .input_video { display: none; }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #score-board {
            font-size: 50px;
            color: #fff;
            text-shadow: 3px 3px 0 #666;
        }

        #target-display {
            font-size: 60px;
            color: #FFD700;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            background: rgba(0,0,0,0.6);
            padding: 10px 30px;
            border-radius: 20px;
            border: 2px solid #FFD700;
        }

        .lives { color: #ff3333; margin-top: 10px; font-size: 40px;}

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
        }

        h1 { color: #FFD700; font-size: 70px; margin: 0; text-shadow: 4px 4px 0 #c41e3a; }
        p { color: #fff; font-size: 28px; margin: 30px 0; max-width: 600px; text-align: center; line-height: 1.5;}
        
        button {
            padding: 20px 60px;
            font-size: 32px;
            background: #2ecc71;
            color: white;
            border: none;
            border-radius: 60px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.6);
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.1); background: #27ae60; }

        #missed-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 100px;
            font-weight: bold;
            color: #e67e22;
            text-shadow: 4px 4px 0 #000;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="bg-pattern"></div>
    <video class="input_video"></video>
    <canvas class="output_canvas"></canvas>
    <div id="missed-text">MISSED!</div>

    <div id="ui-layer">
        <div id="top-bar">
            <div>
                <div id="score-board">SCORE: <span id="score">0</span></div>
                <div class="lives" id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
            </div>
            <div id="target-display">ğŸ‘‚ Listen...</div>
        </div>
    </div>

    <div id="start-screen">
        <h1>ğŸ§ è–èª•è½åŠ›å¿è€…</h1>
        <p>1. è½éŸ³åˆ‡åœ– (ä¾‹å¦‚: "Santa")<br>2. å·¦å³æœƒé£›å‡ºä¸åŒå¡ç‰‡<br>3. åˆ‡å°åŠ åˆ†ï¼Œåˆ‡éŒ¯æ‰£åˆ†</p>
        <p style="font-size: 20px; color: #ccc;">(è«‹é–‹å•Ÿè²éŸ³ä¸¦å…è¨±æ”å½±æ©Ÿ)</p>
        <button onclick="startGame()">START GAME</button>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1>GAME OVER</h1>
        <p>Final Score: <span id="final-score">0</span></p>
        <button onclick="resetGame()">PLAY AGAIN</button>
    </div>
</div>

<script>
    const canvas = document.querySelector('.output_canvas');
    const ctx = canvas.getContext('2d');
    const videoElement = document.querySelector('.input_video');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const targetDisplayEl = document.getElementById('target-display');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const missedTextEl = document.getElementById('missed-text');

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- éŸ³æ•ˆç³»çµ± ---
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    // 1. åˆ‡å°ï¼šåˆ‡æ“Šè²
    function playSliceSound() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const bufferSize = audioCtx.sampleRate * 0.1;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.5, t);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        noise.connect(noiseGain);
        noiseGain.connect(audioCtx.destination);
        noise.start();
        
        const osc = audioCtx.createOscillator();
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
        const oscGain = audioCtx.createGain();
        oscGain.gain.setValueAtTime(0.3, t);
        oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.connect(oscGain);
        oscGain.connect(audioCtx.destination);
        osc.start();
    }

    // 2. åˆ‡éŒ¯ï¼šæ•²æ¡Œè²
    function playTableSound() {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(1.0, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        const filter = audioCtx.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = 300;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
    }

    // --- è³‡æ–™åº« ---
    const VOCAB_DB = [
        { word: 'Santa', icon: 'ğŸ…', color: '#ffcccc' },
        { word: 'Tree', icon: 'ğŸ„', color: '#ccffcc' },
        { word: 'Gift', icon: 'ğŸ', color: '#ffffcc' },
        { word: 'Star', icon: 'â­', color: '#ffffaa' },
        { word: 'Snow', icon: 'â„ï¸', color: '#eefaff' },
        { word: 'Bell', icon: 'ğŸ””', color: '#ffebcd' },
        { word: 'Sock', icon: 'ğŸ§¦', color: '#ffe6e6' },
        { word: 'Deer', icon: 'ğŸ¦Œ', color: '#ebd6ad' },
        { word: 'Elf', icon: 'ğŸ§', color: '#d0f0c0' },
        { word: 'Cake', icon: 'ğŸ‚', color: '#ffccf2' }
    ];

    const GRAVITY = 0.12; 
    const THROW_FORCE = 13;
    
    let gameState = {
        isPlaying: false,
        score: 0,
        lives: 3,
        targetWord: null,
        objects: [],
        particles: [],
        slices: [],
        hand: { x: -100, y: -100, prevX: -100, prevY: -100, speed: 0 }
    };

    let frameCount = 0;

    function speak(text) {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'en-US';
            utterance.rate = 0.9;
            window.speechSynthesis.speak(utterance);
        }
    }

    // --- éŠæˆ²ç‰©ä»¶ (åŒ…å«ä½ç½®é‚è¼¯) ---
    class GameObject {
        constructor(data, laneIndex, totalLanes) {
            this.active = true;
            this.radius = 110;
            
            // --- çµ•å°ä½ç½®é‚è¼¯ (Lanes) ---
            // laneIndex: 0 (å·¦), 1 (ä¸­), 2 (å³)
            // å°‡ç•«é¢å¯¬åº¦å‡åˆ†ï¼Œç¢ºä¿æ¯å¼µå¡ç‰‡æœ‰è‡ªå·±çš„è»Œé“
            
            // è¨ˆç®—è»Œé“ä¸­å¿ƒé» (0.2, 0.5, 0.8)
            // totalLanes å¯èƒ½æ˜¯ 2 æˆ– 3
            let laneWidth = canvas.width / totalLanes;
            let startX = laneWidth * laneIndex + (laneWidth / 2);

            // åŠ å…¥ä¸€é»é»éš¨æ©Ÿåç§» (Â±5%)ï¼Œè®“å®ƒä¸è¦å¤ªæ­»æ¿ï¼Œä½†ä¸æœƒé‡ç–Š
            let randomOffset = (Math.random() - 0.5) * (laneWidth * 0.2);
            
            this.x = startX + randomOffset;
            this.y = canvas.height + 150;

            // --- é€Ÿåº¦æ§åˆ¶ ---
            // å·¦é‚Šçš„å¡ç‰‡ç¨å¾®å¾€å³é£„ï¼Œå³é‚Šçš„å¾€å·¦é£„ï¼Œä¸­é–“çš„ç›´ä¸Š
            let drift = 0;
            if (startX < canvas.width / 2) drift = 1.0; // å¾€å³
            else if (startX > canvas.width / 2) drift = -1.0; // å¾€å·¦
            
            this.vx = drift + (Math.random() - 0.5) * 1; 
            
            this.vy = -(Math.random() * 3 + THROW_FORCE);
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.05;

            // è³‡æ–™è¨­å®š
            this.icon = data.icon;
            this.word = data.word;
            this.color = data.color;
            this.isTarget = (this.word === gameState.targetWord);
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += GRAVITY;
            this.rotation += this.rotationSpeed;
            
            if (this.y > canvas.height + 200 && this.active) {
                this.active = false;
                if (this.isTarget && gameState.isPlaying) {
                    triggerMissed();
                }
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            const w = 220; const h = 280;
            
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.shadowBlur = 15;
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, 15); ctx.fill();
            ctx.fillStyle = this.color;
            ctx.fillRect(-w/2 + 15, -h/2 + 15, w - 30, w - 30);
            ctx.shadowBlur = 0;
            
            ctx.font = "120px Arial";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(this.icon, 0, -20);
            
            ctx.fillStyle = "#000";
            ctx.font = "bold 40px Arial";
            ctx.fillText(this.word, 0, 90);
            
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, isText = false, text = '') {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 15;
            this.vy = (Math.random() - 0.5) * 15;
            this.life = 1.0;
            this.color = color;
            this.isText = isText;
            this.text = text;
        }
        update() {
            this.x += this.vx; this.y += this.vy; this.vy += GRAVITY; this.life -= 0.03;
        }
        draw() {
            ctx.save(); ctx.globalAlpha = this.life;
            if (this.isText) {
                ctx.font = "900 60px Arial"; 
                ctx.fillStyle = this.color; 
                ctx.strokeStyle = "white";
                ctx.lineWidth = 3;
                ctx.strokeText(this.text, this.x, this.y);
                ctx.fillText(this.text, this.x, this.y);
            } else {
                ctx.fillStyle = this.color; 
                ctx.beginPath(); ctx.arc(this.x, this.y, 8, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }
    }

    function initGame() {
        initAudio();
        startScreen.style.display = "none";
        gameOverScreen.style.display = "none";
        gameState.score = 0;
        gameState.lives = 3;
        gameState.objects = [];
        gameState.particles = [];
        gameState.isPlaying = true;
        updateUI();
        setTimeout(spawnWave, 1000);
    }

    function triggerWrongFeedback() {
        gameState.lives--;
        gameState.score -= 5;
        if(gameState.score < 0) gameState.score = 0;
        updateUI();
        playTableSound();
        if (gameState.lives <= 0) endGame();
    }

    function triggerMissed() {
        gameState.lives--;
        gameState.score -= 5; 
        if(gameState.score < 0) gameState.score = 0;
        updateUI();
        missedTextEl.style.opacity = 1;
        setTimeout(() => {
            missedTextEl.style.opacity = 0;
        }, 800);
        if (gameState.lives <= 0) endGame();
    }

    function endGame() {
        gameState.isPlaying = false;
        document.getElementById('final-score').innerText = gameState.score;
        gameOverScreen.style.display = "flex";
    }

    function updateUI() {
        scoreEl.innerText = gameState.score;
        let livesStr = "";
        for(let i=0; i<gameState.lives; i++) livesStr += "â¤ï¸";
        livesEl.innerHTML = livesStr;
    }

    // --- æ ¸å¿ƒï¼šç™¼å°„æ³¢ ---
    function spawnWave() {
        if(!gameState.isPlaying) return;

        // 1. æ±ºå®šé¡Œç›®
        const targetData = VOCAB_DB[Math.floor(Math.random() * VOCAB_DB.length)];
        gameState.targetWord = targetData.word;

        // 2. æ’­æ”¾èªéŸ³ (åªå”¸å–®å­—)
        targetDisplayEl.innerText = "ğŸ‘‚ Listen...";
        speak(gameState.targetWord); // åªå”¸å–®å­—ï¼Œæ‹¿æ‰ Find...
        
        setTimeout(() => {
            if(gameState.isPlaying) targetDisplayEl.innerText = "Target: " + gameState.targetWord;
        }, 1500);

        // 3. æº–å‚™å¡ç‰‡è³‡æ–™
        // ä¸€æ¬¡å›ºå®šå‡º 3 å¼µ (å·¦ã€ä¸­ã€å³)
        let totalCount = 3;
        let cardsToSpawn = [];
        
        // æ”¾å…¥ç›®æ¨™å¡
        cardsToSpawn.push(targetData);
        
        // æ”¾å…¥å…¶ä»–å¹²æ“¾å¡ (ä¸é‡è¤‡)
        while(cardsToSpawn.length < totalCount) {
            let wrongData = VOCAB_DB[Math.floor(Math.random() * VOCAB_DB.length)];
            // æª¢æŸ¥æ˜¯å¦é‡è¤‡
            let isDuplicate = cardsToSpawn.some(c => c.word === wrongData.word);
            if (!isDuplicate) cardsToSpawn.push(wrongData);
        }

        // éš¨æ©Ÿæ‰“äº‚é€™äº›å¡ç‰‡çš„ä½ç½® (Shuffle)
        for (let i = cardsToSpawn.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [cardsToSpawn[i], cardsToSpawn[j]] = [cardsToSpawn[j], cardsToSpawn[i]];
        }

        // 4. ç”Ÿæˆç‰©ä»¶ (æŒ‡å®šè»Œé“)
        // ä½¿ç”¨ i ä½œç‚º laneIndex (0, 1, 2)
        for(let i=0; i<totalCount; i++) {
            // æ¯å€‹ç‰©ä»¶ç”Ÿæˆæ™‚çµ¦äºˆå¾®å°å»¶é²ï¼Œé¿å…ç¬é–“å…¨éƒ¨å†’å‡ºä¾†å¤ªåš‡äºº
            // ä½†å› ç‚ºè»Œé“ä¸åŒï¼Œå…¶å¯¦åŒæ™‚å‡ºä¾†ä¹Ÿä¸æœƒé‡ç–Š
            setTimeout(() => {
                if(!gameState.isPlaying) return;
                gameState.objects.push(new GameObject(cardsToSpawn[i], i, totalCount));
            }, i * 200); 
        }

        setTimeout(spawnWave, 4000);
    }

    function gameLoop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        frameCount++;

        if (gameState.isPlaying) {
            for (let i = gameState.objects.length - 1; i >= 0; i--) {
                let obj = gameState.objects[i];
                obj.update();
                obj.draw();

                if (!obj.active) {
                    gameState.objects.splice(i, 1);
                    continue;
                }

                let dx = gameState.hand.x - obj.x;
                let dy = gameState.hand.y - obj.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < obj.radius && gameState.hand.speed > 3) {
                    if (obj.word === gameState.targetWord) {
                        gameState.score += 10;
                        playSliceSound(); 
                        createSliceEffect(obj, true);
                        gameState.objects.splice(i, 1);
                        updateUI();
                    } else {
                        triggerWrongFeedback(); 
                        createSliceEffect(obj, false);
                        gameState.objects.splice(i, 1);
                    }
                }
            }
        }

        for (let i = gameState.particles.length - 1; i >= 0; i--) {
            let p = gameState.particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) gameState.particles.splice(i, 1);
        }

        drawBlade();
        requestAnimationFrame(gameLoop);
    }

    function createSliceEffect(obj, isCorrect) {
        let color = isCorrect ? "#2ecc71" : "#e74c3c";
        let msg = isCorrect ? "YES!" : "WRONG!";
        for (let i = 0; i < 15; i++) gameState.particles.push(new Particle(obj.x, obj.y, color));
        gameState.particles.push(new Particle(obj.x, obj.y, color, true, msg));
    }

    function drawBlade() {
        if (gameState.slices.length < 2) return;
        ctx.beginPath();
        ctx.moveTo(gameState.slices[0].x, gameState.slices[0].y);
        for (let i = 1; i < gameState.slices.length; i++) {
            let point = gameState.slices[i];
            ctx.lineTo(point.x, point.y);
        }
        ctx.shadowBlur = 20;
        ctx.shadowColor = "#00ffff";
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 10;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.stroke();
        ctx.shadowBlur = 0;
        if (gameState.slices.length > 10) gameState.slices.shift();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const x = landmarks[8].x * canvas.width;
            const y = landmarks[8].y * canvas.height;
            const dx = x - gameState.hand.prevX;
            const dy = y - gameState.hand.prevY;
            gameState.hand.speed = Math.sqrt(dx*dx + dy*dy);
            gameState.hand.prevX = gameState.hand.x;
            gameState.hand.prevY = gameState.hand.y;
            gameState.hand.x = x;
            gameState.hand.y = y;
            gameState.slices.push({x: x, y: y});
        } else {
            gameState.hand.speed = 0;
            if(gameState.slices.length > 0) gameState.slices.shift(); 
        }
    });

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280,
        height: 720
    });
    
    camera.start();
    gameLoop();
    window.startGame = initGame;
    window.resetGame = initGame;

</script>
</body>
</html>
