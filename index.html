<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>è–èª•å…‰åŠ (æ‰‹æ©Ÿå„ªåŒ–ç‰ˆ)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

<style>
  body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #0b1e10;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    cursor: none; /* éš±è—æ»‘é¼  */
    touch-action: none; /* ç¦æ­¢æ‰‹æ©Ÿæ²å‹• */
  }

  /* UI å±¤ */
  #ui-layer {
    position: absolute; top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    z-index: 20;
  }

  /* éŸ¿æ‡‰å¼é–‹å§‹é¢æ¿ */
  #start-overlay {
    background: linear-gradient(135deg, #c0392b, #8e44ad);
    padding: 5vmin; 
    border-radius: 20px;
    text-align: center; color: white;
    border: 4px solid #f1c40f; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    pointer-events: auto;
    width: 85%;
    max-width: 400px;
    transition: transform 0.2s;
  }
  #start-overlay:hover { transform: scale(1.02); }

  h1 { margin: 0 0 10px 0; font-size: 8vmin; text-shadow: 2px 2px 0px #000; }
  p { font-size: 4vmin; margin-bottom: 20px; line-height: 1.5; }

  button {
    padding: 12px 30px;
    font-size: 5vmin; 
    background: #27ae60; 
    color: white; 
    border: 3px solid #f1c40f; 
    border-radius: 50px;
    cursor: pointer; 
    font-weight: bold;
    box-shadow: 0 5px 0 #1e8449;
    white-space: nowrap;
  }
  button:active { transform: translateY(3px); box-shadow: none; }

  .hidden { display: none !important; }

  /* è½åŠ›æç¤º */
  #listen-hint {
    position: absolute; top: 15%; width: 100%;
    text-align: center; font-size: 15vmin; 
    color: #f1c40f; 
    font-weight: 900; 
    text-shadow: 4px 4px 0px #c0392b; 
    display: none; opacity: 0; transition: opacity 0.3s;
    pointer-events: none;
    z-index: 10;
  }
  #listen-hint.show { display: block; opacity: 1; }
  
  @media (min-width: 800px) {
    h1 { font-size: 3rem; }
    p { font-size: 1.2rem; }
    button { font-size: 1.8rem; }
    #listen-hint { font-size: 5rem; }
  }
</style>
</head>
<body>

  <div id="listen-hint">ğŸ”Š Listen!</div>

  <div id="ui-layer">
    <div id="start-overlay">
      <h1>ğŸ„ Christmas Saber</h1>
      <p>1. è½è‹±æ–‡å–®å­—<br>2. å¡ç‰‡æœƒæ…¢æ…¢é£›å‡º<br>3. æ»‘å‹•æ‰‹æŒ‡åˆ‡é–‹å®ƒï¼</p>
      <button onclick="startGame()">Start ğŸ…</button>
    </div>
  </div>

<script>
// --- è³‡æ–™åº« ---
const gameData = [
    { word: "Santa", icon: "ğŸ…", color: "#c0392b" },
    { word: "Tree", icon: "ğŸ„", color: "#27ae60" },
    { word: "Gift", icon: "ğŸ", color: "#f1c40f" },
    { word: "Snowman", icon: "â›„", color: "#3498db" },
    { word: "Star", icon: "â­", color: "#f1c40f" },
    { word: "Bell", icon: "ğŸ””", color: "#e67e22" },
    { word: "Cookie", icon: "ğŸª", color: "#8d6e63" },
    { word: "Candy", icon: "ğŸ¬", color: "#e91e63" },
    { word: "Sock", icon: "ğŸ§¦", color: "#c0392b" },
    { word: "Angel", icon: "ğŸ‘¼", color: "#f39c12" },
    { word: "Reindeer", icon: "ğŸ¦Œ", color: "#8d6e63" },
    { word: "Sleigh", icon: "ğŸ›·", color: "#c0392b" },
    { word: "Elf", icon: "ğŸ§", color: "#27ae60" },
    { word: "Snowflake", icon: "â„ï¸", color: "#a2d9ff" },
    { word: "Candle", icon: "ğŸ•¯ï¸", color: "#f39c12" },
    { word: "Turkey", icon: "ğŸ¦ƒ", color: "#d35400" },
    { word: "Ribbon", icon: "ğŸ€", color: "#e91e63" },
    { word: "Gloves", icon: "ğŸ§¤", color: "#16a085" },
    { word: "Scarf", icon: "ğŸ§£", color: "#e74c3c" },
    { word: "Toy", icon: "ğŸ§¸", color: "#9b59b6" }
];

const phrasesCorrect = ["Awesome!", "Perfect!", "Excellent!", "Great Job!", "Fantastic!", "You Rock!"];
const phrasesWrong = ["Try Again!", "Don't Give Up!", "Keep Going!", "Nice Try!", "Almost There!", "You Can Do It!"];

let isGameRunning = false;
let score = 0;
let cards = [];
let particles = [];
let saberTrail = [];
let snowFlakes = []; 
let synth = window.speechSynthesis;
let currentTargetWord = "";
const SPEECH_RATE = 0.85; 

// éŸ¿æ‡‰å¼è®Šæ•¸
let R = {
    cardSize: 0,
    emojiSize: 0,
    textSize: 0,
    borderW: 0,
    feedbackSize: 0,
    scoreSize: 0
};

let feedback = { text: "", life: 0, y: 0, scale: 1 };

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);
  rectMode(CENTER);
  
  calculateResponsiveSizes(); 

  for(let i=0; i<60; i++) {
    snowFlakes.push({
      x: random(width), y: random(height),
      size: random(2, 6), speed: random(0.5, 2.5)
    });
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  calculateResponsiveSizes();
}

// *** èª¿æ•´å¾Œçš„å°ºå¯¸è¨ˆç®— (å¡ç‰‡è®Šå°) ***
function calculateResponsiveSizes() {
    let minDim = min(width, height);
    let isPortrait = width < height;

    if (isPortrait) {
        // æ‰‹æ©Ÿç›´å‘ï¼šå¯¬åº¦çš„ 18% (åŸæœ¬22%)ï¼Œæœ€å°60pxï¼Œæœ€å¤§130px
        R.cardSize = constrain(width * 0.18, 60, 130);
    } else {
        // é›»è…¦/æ©«å‘ï¼šé«˜åº¦çš„ 18%
        R.cardSize = constrain(height * 0.18, 80, 150);
    }

    R.emojiSize = R.cardSize * 0.6;
    R.textSize = R.cardSize * 0.22; // å­—é«”æ¯”ä¾‹ç¨å¾®åŠ å¤§ï¼Œé¿å…å¡ç‰‡è®Šå°å­—çœ‹ä¸æ¸…
    
    R.borderW = minDim * 0.03; // é‚Šæ¡†è®Šç´°
    R.feedbackSize = minDim * 0.15;
    R.scoreSize = minDim * 0.06;
}

function startGame() {
  document.getElementById('start-overlay').classList.add('hidden');
  if(synth) synth.speak(new SpeechSynthesisUtterance("")); 
  isGameRunning = true;
  score = 0;
  setTimeout(startRound, 800);
}

function startRound() {
  if(!isGameRunning) return;

  let targetData = random(gameData);
  currentTargetWord = targetData.word;
  
  let distractorData;
  do { distractorData = random(gameData); } while(distractorData.word === targetData.word);

  let hint = document.getElementById('listen-hint');
  hint.classList.add('show');
  hint.innerText = "ğŸ”Š Listen...";

  speak(targetData.word, null, SPEECH_RATE);

  setTimeout(() => {
    hint.classList.remove('show');
    spawnCards(targetData, distractorData);
  }, 1000); 
}

function spawnCards(target, distractor) {
  let items = [target, distractor];
  if (random() > 0.5) items.reverse();

  // ç¨å¾®å¾€ä¸­é–“é æ”ä¸€é»ï¼Œé¿å…æ‰‹æ©Ÿé‚Šç·£èª¤è§¸
  let startLeft = { x: width * 0.2, y: height + 50 };
  let startRight = { x: width * 0.8, y: height + 50 };
  let targetLeft = { x: width * 0.4, y: height * 0.2 };
  let targetRight = { x: width * 0.6, y: height * 0.2 };

  launchCard(startLeft.x, startLeft.y, targetLeft.x, targetLeft.y, items[0], items[0].word === currentTargetWord);
  launchCard(startRight.x, startRight.y, targetRight.x, targetRight.y, items[1], items[1].word === currentTargetWord);
}

function launchCard(startX, startY, destX, destY, data, isTarget) {
    let gravity = 0.12; 
    let heightDiff = startY - destY;
    let vy = -Math.sqrt(2 * gravity * heightDiff); 
    let timeToPeak = Math.abs(vy / gravity);
    let vx = (destX - startX) / timeToPeak;

    cards.push({
        x: startX, y: startY,
        vx: vx, vy: vy,
        gravity: gravity,
        size: R.cardSize, 
        angle: 0, rotSpeed: random(-0.01, 0.01), 
        data: data, isTarget: isTarget,
        draw: function() {
            push();
            translate(this.x, this.y); rotate(this.angle);
            fill(255); 
            stroke(isTarget ? "#c0392b" : "#2c3e50"); 
            strokeWeight(3); // ç·šæ¢ä¹Ÿè®Šç´°ä¸€é»
            rect(0, 0, this.size, this.size * 1.3, 15);
            textSize(R.emojiSize); noStroke(); text(this.data.icon, 0, -this.size*0.15);
            fill(0); textSize(R.textSize); textStyle(BOLD); text(this.data.word, 0, this.size*0.4);
            pop();
        },
        update: function() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.angle += this.rotSpeed;
        }
    });
}

function draw() {
  setGradient(0, 0, width, height, color(11, 30, 16), color(5, 10, 5));
  drawSnow();
  drawChristmasBorder();

  if(!isGameRunning) return;

  updateSaber(mouseX, mouseY);
  drawSaberOptimized();

  for (let i = cards.length - 1; i >= 0; i--) {
    let c = cards[i];
    if (!c) continue; 
    c.update();
    c.draw();

    // ç¢°æ’ç¯„åœéš¨å¡ç‰‡å¤§å°èª¿æ•´
    if (dist(mouseX, mouseY, c.x, c.y) < c.size/2 + 20) {
        handleHit(c, i);
        break; 
    } 
    else if (c.y > height + 200) {
      cards.splice(i, 1);
      if(cards.length === 0) setTimeout(startRound, 1000);
    }
  }

  drawParticles();
  drawFeedback();

  fill(255); textSize(R.scoreSize); textStyle(BOLD); noStroke();
  textAlign(LEFT, TOP);
  // åˆ†æ•¸ä½ç½®é¿é–‹é‚Šæ¡†
  text("Score: " + score, R.borderW + 15, R.borderW + 15);
  textAlign(CENTER, CENTER);
}

function createExplosion(x, y, colorHex) {
  for (let i = 0; i < 30; i++) {
    particles.push(new Particle(x, y, colorHex, 'debris'));
  }
  for (let i = 0; i < 20; i++) {
    particles.push(new Particle(x, y, '#ffd700', 'sparkle'));
  }
}

class Particle {
    constructor(x, y, col, type) {
        this.x = x; this.y = y; this.col = col; this.type = type;
        let angle = random(TWO_PI);
        let speed = random(min(width,height)*0.01, min(width,height)*0.03); 
        this.vx = cos(angle) * speed;
        this.vy = sin(angle) * speed;
        this.life = 255;
        this.gravity = 0.4;
        this.friction = 0.94;
        let baseScale = min(width, height) / 800;
        this.size = (type === 'debris' ? random(8, 16) : random(3, 8)) * baseScale;
        this.rot = random(TWO_PI); this.rotSpeed = random(-0.3, 0.3);
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.vy += this.gravity;
        this.vx *= this.friction; this.vy *= this.friction;
        this.life -= this.type === 'debris' ? 5 : 8;
        this.rot += this.rotSpeed; this.size *= 0.96;
    }
    draw() {
        push(); translate(this.x, this.y); rotate(this.rot); noStroke();
        let c = color(this.col); c.setAlpha(this.life); fill(c);
        if (this.type === 'debris') rect(0, 0, this.size, this.size);
        else { blendMode(ADD); circle(0, 0, this.size); blendMode(BLEND); }
        pop();
    }
}

function drawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.update(); p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function triggerFeedback(isCorrect) {
    feedback.text = isCorrect ? random(phrasesCorrect) : random(phrasesWrong);
    feedback.life = 255; feedback.y = height / 2; feedback.scale = 0.5;
}

function drawFeedback() {
    if (feedback.life > 0) {
        push();
        translate(width / 2, feedback.y);
        scale(feedback.scale);
        let goldColor = color(255, 215, 0, feedback.life);
        drawingContext.shadowBlur = 40; drawingContext.shadowColor = 'rgba(255, 215, 0, 0.8)';
        fill(goldColor); stroke(255, feedback.life); strokeWeight(3);
        textSize(R.feedbackSize); 
        textStyle(BOLD); text(feedback.text, 0, 0);
        feedback.life -= 4; feedback.y -= 1.5;
        if(feedback.scale < 1.2) feedback.scale += 0.05;
        drawingContext.shadowBlur = 0;
        pop();
    }
}

function handleHit(card, index) {
  cards.splice(index, 1);
  createExplosion(card.x, card.y, card.data.color);
  if (card.isTarget) {
    score += 10;
    triggerFeedback(true);
    speak(feedback.text, null, SPEECH_RATE);
    cards = []; setTimeout(startRound, 1200);
  } else {
    triggerFeedback(false);
    speak(feedback.text, null, SPEECH_RATE);
    cards = []; setTimeout(startRound, 1200);
  }
}

function drawChristmasBorder() {
  push(); rectMode(CORNER); noStroke();
  let borderW = R.borderW; 
  let stripeLen = borderW * 1.5; 
  let redC = color('#c0392b'); let greenC = color('#27ae60');

  for(let x = 0; x < width; x += stripeLen) {
    fill((x / stripeLen) % 2 === 0 ? redC : greenC); rect(x, 0, stripeLen, borderW);
    fill((x / stripeLen) % 2 !== 0 ? redC : greenC); rect(x, height - borderW, stripeLen, borderW);
  }
  for(let y = borderW; y < height - borderW; y += stripeLen) {
    fill((y / stripeLen) % 2 === 0 ? redC : greenC); rect(0, y, borderW, stripeLen);
    fill((y / stripeLen) % 2 !== 0 ? redC : greenC); rect(width - borderW, y, borderW, stripeLen);
  }
  
  fill(redC); rect(0,0,borderW,borderW);
  fill(greenC); rect(width-borderW,0,borderW,borderW);
  fill(greenC); rect(0,height-borderW,borderW,borderW);
  fill(redC); rect(width-borderW,height-borderW,borderW,borderW);
  pop();
}

function updateSaber(x, y) {
  saberTrail.push({x: x, y: y, life: 8});
  for (let i = saberTrail.length - 1; i >= 0; i--) {
    saberTrail[i].life--;
    if (saberTrail[i].life <= 0) saberTrail.splice(i, 1);
  }
}

function drawSaberOptimized() {
  if (saberTrail.length < 2) return;
  blendMode(ADD); 
  noFill(); strokeCap(ROUND); strokeJoin(ROUND);
  stroke(255, 0, 0, 100); strokeWeight(25);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  stroke(255, 50, 50, 200); strokeWeight(15);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  stroke(255, 255, 255, 255); strokeWeight(5);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  blendMode(BLEND); 
}

function drawSnow() {
  fill(255, 100); noStroke();
  for(let s of snowFlakes) {
    circle(s.x, s.y, s.size);
    s.y += s.speed;
    if(s.y > height) s.y = -10;
  }
}

function setGradient(x, y, w, h, c1, c2) {
  noFill();
  for (let i = y; i <= y + h; i+=10) { 
    let inter = map(i, y, y + h, 0, 1);
    let c = lerpColor(c1, c2, inter);
    stroke(c); strokeWeight(10);
    line(x, i, x + w, i);
  }
}

function speak(text, callback, rate = 1.0) {
  synth.cancel();
  let u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US'; u.rate = rate; 
  if(callback) u.onend = callback;
  synth.speak(u);
}
</script>
</body>
</html>
