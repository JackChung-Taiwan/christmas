<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è–èª•å–®å­—é«”æ„Ÿé–ƒå¡</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(ellipse at center, #1a472a 0%, #0d2b1a 100%); /* è–èª•ç¶ èƒŒæ™¯ */
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
        }

        #game-container {
            position: relative;
            width: 1280px;
            height: 720px;
            box-shadow: 0 0 30px rgba(255,0,0,0.3);
            background: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            overflow: hidden;
            border: 5px solid #c41e3a; /* è–èª•ç´…é‚Šæ¡† */
        }

        .input_video { display: none; }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* é¡åƒç¿»è½‰ */
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 26px;
            background: rgba(196, 30, 58, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        /* éŠæˆ²ä»‹é¢æ–‡å­— */
        .ui-text {
            position: absolute;
            pointer-events: none;
            width: 100%;
            text-align: center;
            text-shadow: 2px 2px 4px #000;
        }
        #top-instruction { top: 20px; font-size: 24px; color: #ffd700; }
        #score-board { top: 60px; font-size: 28px; }
        #result-feedback { 
            top: 40%; 
            font-size: 60px; 
            font-weight: bold; 
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>

<div id="game-container">
    <video class="input_video"></video>
    <canvas class="output_canvas" width="1280" height="720"></canvas>
    
    <div id="top-instruction" class="ui-text">è«‹å°‡æ‰‹åœç•™åœ¨æ­£ç¢ºç­”æ¡ˆä¸Šæ–¹ä¾†é¸æ“‡ (Hover to Select)</div>
    <div id="score-board" class="ui-text">å¾—åˆ†: <span id="score">0</span> / é¡Œæ•¸: <span id="question-count">0</span></div>
    <div id="result-feedback" class="ui-text">Correct!</div>

    <div id="loading">
        ğŸ„ æº–å‚™è–èª•æ•™æä¸­...<br>è«‹å…è¨±æ”å½±æ©Ÿæ¬Šé™<br>ä¸¦èˆ‰èµ·ä½ çš„æ‰‹
    </div>
</div>

<script>
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const loadingEl = document.getElementById('loading');
    const scoreEl = document.getElementById('score');
    const qCountEl = document.getElementById('question-count');
    const feedbackEl = document.getElementById('result-feedback');

    // --- è³‡æ–™åº« ---
    const vocabList = [
        { emoji: 'ğŸ…', word: 'Santa Claus' },
        { emoji: 'ğŸ„', word: 'Christmas Tree' },
        { emoji: 'ğŸ', word: 'Gift' },
        { emoji: 'ğŸ¦Œ', word: 'Reindeer' },
        { emoji: 'â›„', word: 'Snowman' },
        { emoji: 'ğŸ””', word: 'Bell' },
        { emoji: 'ğŸ§¦', word: 'Stocking' },
        { emoji: 'ğŸª', word: 'Cookie' },
        { emoji: 'ğŸ¥›', word: 'Milk' },
        { emoji: 'â­', word: 'Star' },
        { emoji: 'â„ï¸', word: 'Snowflake' },
        { emoji: 'ğŸ•¯ï¸', word: 'Candle' }
    ];

    // --- éŠæˆ²ç‹€æ…‹ ---
    let gameState = {
        score: 0,
        questionCount: 0,
        isHandsDetected: false,
        handX: 0,
        handY: 0,
        currentQuestion: null,
        options: [], // å­˜æ”¾ä¸‰å€‹æŒ‰éˆ•ç‰©ä»¶
        isProcessingAnswer: false // é˜²æ­¢é‡è¤‡è§¸ç™¼
    };

    // --- æŒ‰éˆ•é¡åˆ¥ ---
    class OptionButton {
        constructor(x, y, width, height, text, isCorrect) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.text = text;
            this.isCorrect = isCorrect;
            this.hoverProgress = 0; // 0 åˆ° 100
            this.hoverSpeed = 2.5; // æ‡¸åœå¢åŠ é€Ÿåº¦
        }

        draw(ctx, handX, handY) {
            // æª¢æŸ¥æ˜¯å¦æ‡¸åœ
            let isHovering = handX > this.x && handX < this.x + this.width &&
                             handY > this.y && handY < this.y + this.height;

            if (isHovering && !gameState.isProcessingAnswer) {
                this.hoverProgress = Math.min(100, this.hoverProgress + this.hoverSpeed);
            } else {
                this.hoverProgress = Math.max(0, this.hoverProgress - this.hoverSpeed * 2);
            }
            
            // ç¹ªè£½æŒ‰éˆ•èƒŒæ™¯
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            if (this.hoverProgress >= 100) ctx.fillStyle = "#FFD700"; // è§¸ç™¼æ™‚è®Šé‡‘è‰²

            ctx.beginPath();
            ctx.roundRect(this.x, this.y, this.width, this.height, 15);
            ctx.fill();
            ctx.lineWidth = 4;
            ctx.strokeStyle = "#c41e3a"; // ç´…æ¡†
            ctx.stroke();

            // ç¹ªè£½æ‡¸åœé€²åº¦æ¢ (åº•éƒ¨å¡«å……)
            if (this.hoverProgress > 0) {
                let progressHeight = (this.hoverProgress / 100) * this.height;
                ctx.fillStyle = "rgba(46, 204, 113, 0.6)"; // ç¶ è‰²é€²åº¦
                ctx.beginPath();
                // åªå¡«å……åº•éƒ¨ä¸€éƒ¨åˆ†
                 ctx.roundRect(this.x, this.y + this.height - progressHeight, this.width, progressHeight, [0,0,15,15]);
                ctx.fill();
            }

            // ç¹ªè£½æ–‡å­—
            ctx.fillStyle = "#000";
            ctx.font = "bold 36px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height / 2);

            return this.hoverProgress >= 100; // å›å‚³æ˜¯å¦è§¸ç™¼é¸æ“‡
        }
    }

    // --- éŠæˆ²é‚è¼¯ ---

    function startNewRound() {
        gameState.isProcessingAnswer = false;
        gameState.questionCount++;
        qCountEl.innerText = gameState.questionCount;

        // 1. é¸å‡ºæ­£ç¢ºç­”æ¡ˆ
        let correctIndex = Math.floor(Math.random() * vocabList.length);
        gameState.currentQuestion = vocabList[correctIndex];

        // 2. é¸å‡ºå…©å€‹éŒ¯èª¤ç­”æ¡ˆ
        let wrongOptions = [];
        let temp List = [...vocabList];
        temp List.splice(correctIndex, 1); // ç§»é™¤æ­£ç¢ºç­”æ¡ˆ
        shuffleArray(temp List);
        wrongOptions.push(temp List[0].word);
        wrongOptions.push(temp List[1].word);

        // 3. çµ„åˆä¸¦æ‰“äº‚é¸é …
        let finalOptionsWords = [gameState.currentQuestion.word, ...wrongOptions];
        shuffleArray(finalOptionsWords);

        // 4. å»ºç«‹æŒ‰éˆ•ç‰©ä»¶
        gameState.options = [];
        const btnWidth = 300;
        const btnHeight = 100;
        const startX = (canvasElement.width - (btnWidth * 3 + 40 * 2)) / 2;
        const btnY = 500;

        for (let i = 0; i < 3; i++) {
            let isCorrect = (finalOptionsWords[i] === gameState.currentQuestion.word);
            gameState.options.push(new OptionButton(
                startX + i * (btnWidth + 40),
                btnY,
                btnWidth,
                btnHeight,
                finalOptionsWords[i],
                isCorrect
            ));
        }
    }

    function handleChoice(selectedBtn) {
        gameState.isProcessingAnswer = true;
        
        if (selectedBtn.isCorrect) {
            gameState.score += 10;
            showFeedback("Correct! âœ…", "#2ecc71");
        } else {
             showFeedback("Wrong! âŒ", "#e74c3c");
        }
        scoreEl.innerText = gameState.score;

        // 2ç§’å¾Œä¸‹ä¸€é¡Œ
        setTimeout(() => {
            feedbackEl.style.opacity = 0;
            startNewRound();
        }, 2000);
    }

    function showFeedback(text, color) {
        feedbackEl.innerText = text;
        feedbackEl.style.color = color;
        feedbackEl.style.opacity = 1;
    }

    // è¼”åŠ©å‡½å¼ï¼šé™£åˆ—æ´—ç‰Œ
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }


    // --- MediaPipe è¨­å®š ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280,
        height: 720
    });

    function onResults(results) {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        if (loadingEl.style.display !== 'none' && results.multiHandLandmarks.length > 0) {
            loadingEl.style.display = 'none';
            startNewRound();
        }

        // 1. è™•ç†æ‰‹éƒ¨è¿½è¹¤
        if (results.multiHandLandmarks.length > 0) {
            gameState.isHandsDetected = true;
            const landmarks = results.multiHandLandmarks[0];
            // ä½¿ç”¨é£ŸæŒ‡æŒ‡å°– (Index Finger Tip, ID: 8)
            gameState.handX = landmarks[8].x * canvasElement.width;
            gameState.handY = landmarks[8].y * canvasElement.height;
        } else {
            gameState.isHandsDetected = false;
        }

        // 2. ç¹ªè£½éŠæˆ²å…§å®¹
        if (gameState.currentQuestion) {
            // ç¹ªè£½é¡Œç›® Emoji
            canvasCtx.font = "200px Arial";
            canvasCtx.textAlign = "center";
            canvasCtx.textBaseline = "middle";
            canvasCtx.fillText(gameState.currentQuestion.emoji, canvasElement.width / 2, 250);

            // ç¹ªè£½é¸é …æŒ‰éˆ•ä¸¦æª¢æŸ¥äº’å‹•
            let triggeredBtn = null;
            gameState.options.forEach(btn => {
                // å¦‚æœæ‰‹æœ‰åµæ¸¬åˆ°ï¼Œå‚³å…¥åº§æ¨™ï¼Œå¦å‰‡å‚³å…¥ç•«é¢å¤–åº§æ¨™
                let isTriggered = btn.draw(canvasCtx, 
                    gameState.isHandsDetected ? gameState.handX : -100, 
                    gameState.isHandsDetected ? gameState.handY : -100
                );
                if (isTriggered) triggeredBtn = btn;
            });

            // å¦‚æœæœ‰æŒ‰éˆ•è¢«è§¸ç™¼ä¸”å°šæœªè™•ç†
            if (triggeredBtn && !gameState.isProcessingAnswer) {
                handleChoice(triggeredBtn);
            }
        }

        // 3. æœ€å¾Œç¹ªè£½æ‰‹éƒ¨æ¸¸æ¨™ (åœ¨æœ€ä¸Šå±¤)
        if (gameState.isHandsDetected) {
            drawCursor(gameState.handX, gameState.handY);
        } else if (loadingEl.style.display === 'none') {
            // æç¤ºæ‰¾ä¸åˆ°æ‰‹
             canvasCtx.font = "30px Arial";
             canvasCtx.fillStyle = "rgba(255,255,255,0.7)";
             canvasCtx.textAlign = "center";
             canvasCtx.fillText("æ‰¾ä¸åˆ°æ‰‹æ‰‹... ğŸ–ï¸", canvasElement.width/2, canvasElement.height - 50);
        }
    }

    function drawCursor(x, y) {
        canvasCtx.font = "80px Arial";
        canvasCtx.textAlign = "center";
        canvasCtx.textBaseline = "top"; // æŒ‡å°–åœ¨ä¸Šæ–¹
        // ç¹ªè£½æ‰‹æŒ‡æ¸¸æ¨™
        canvasCtx.fillText("ğŸ‘†", x, y);
        
        // ç¹ªè£½ä¸€å€‹å°å…‰æšˆè®“å®ƒæ›´æ˜é¡¯
        canvasCtx.beginPath();
        canvasCtx.arc(x, y + 10, 15, 0, 2 * Math.PI);
        canvasCtx.fillStyle = "rgba(255, 215, 0, 0.5)"; // é‡‘è‰²å…‰æšˆ
        canvasCtx.fill();
    }

    camera.start();

</script>

</body>
</html>
