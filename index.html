<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>è–èª•å…‰åŠ (ç‚«éº—ç‰¹æ•ˆç‰ˆ)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

<style>
  body {
    margin: 0; padding: 0; overflow: hidden;
    background-color: #0b1e10;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    cursor: none; /* éš±è—æ»‘é¼ ï¼Œç”±å…‰åŠå–ä»£ */
  }

  /* UI å±¤ */
  #ui-layer {
    position: absolute; top: 0; left: 0;
    width: 100vw; height: 100vh;
    pointer-events: none;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    z-index: 20;
  }

  /* é–‹å§‹é¢æ¿ */
  #start-overlay {
    background: linear-gradient(135deg, #c0392b, #8e44ad);
    padding: 40px 60px; 
    border-radius: 25px;
    text-align: center; color: white;
    border: 5px solid #f1c40f; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    pointer-events: auto;
    transition: transform 0.2s;
  }
  #start-overlay:hover { transform: scale(1.02); }

  h1 { margin: 0 0 15px 0; font-size: 2.5rem; text-shadow: 2px 2px 0px #000; }
  p { font-size: 1.2rem; margin-bottom: 25px; line-height: 1.6; }

  button {
    padding: 15px 50px;
    font-size: 1.8rem; 
    background: #27ae60; 
    color: white; 
    border: 3px solid #f1c40f; 
    border-radius: 50px;
    cursor: pointer; 
    font-weight: bold;
    box-shadow: 0 5px 0 #1e8449;
    transition: all 0.1s;
  }
  button:active { transform: translateY(5px); box-shadow: 0 0 0 #1e8449; }

  .hidden { display: none !important; }

  #listen-hint {
    position: absolute; top: 15%; width: 100%;
    text-align: center; font-size: 5rem; 
    color: #f1c40f; 
    font-weight: 900; 
    text-shadow: 4px 4px 0px #c0392b; 
    display: none; opacity: 0; transition: opacity 0.3s;
    pointer-events: none;
    z-index: 10;
  }
  #listen-hint.show { display: block; opacity: 1; }
</style>
</head>
<body>

  <div id="listen-hint">ğŸ”Š Listen!</div>

  <div id="ui-layer">
    <div id="start-overlay">
      <h1>ğŸ„ Christmas Saber</h1>
      <p>1. ä»”ç´°è½è‹±æ–‡å–®å­—<br>2. å¡ç‰‡æœƒ<b>æ…¢æ…¢é£›</b>å‘è¢å¹•ä¸Šæ–¹<br>3. æ»‘å‹•æ»‘é¼ åˆ‡é–‹æ­£ç¢ºçš„å¡ç‰‡ï¼</p>
      <button onclick="startGame()">Start ğŸ…</button>
    </div>
  </div>

<script>
// --- è³‡æ–™åº« (20å€‹å–®å­—) ---
const gameData = [
    { word: "Santa", icon: "ğŸ…", color: "#c0392b" },
    { word: "Tree", icon: "ğŸ„", color: "#27ae60" },
    { word: "Gift", icon: "ğŸ", color: "#f1c40f" },
    { word: "Snowman", icon: "â›„", color: "#3498db" },
    { word: "Star", icon: "â­", color: "#f1c40f" },
    { word: "Bell", icon: "ğŸ””", color: "#e67e22" },
    { word: "Cookie", icon: "ğŸª", color: "#8d6e63" },
    { word: "Candy", icon: "ğŸ¬", color: "#e91e63" },
    { word: "Sock", icon: "ğŸ§¦", color: "#c0392b" },
    { word: "Angel", icon: "ğŸ‘¼", color: "#f39c12" },
    { word: "Reindeer", icon: "ğŸ¦Œ", color: "#8d6e63" },
    { word: "Sleigh", icon: "ğŸ›·", color: "#c0392b" },
    { word: "Elf", icon: "ğŸ§", color: "#27ae60" },
    { word: "Snowflake", icon: "â„ï¸", color: "#a2d9ff" },
    { word: "Candle", icon: "ğŸ•¯ï¸", color: "#f39c12" },
    { word: "Turkey", icon: "ğŸ¦ƒ", color: "#d35400" },
    { word: "Ribbon", icon: "ğŸ€", color: "#e91e63" },
    { word: "Gloves", icon: "ğŸ§¤", color: "#16a085" },
    { word: "Scarf", icon: "ğŸ§£", color: "#e74c3c" },
    { word: "Toy", icon: "ğŸ§¸", color: "#9b59b6" }
];

const phrasesCorrect = ["Awesome!", "Perfect!", "Excellent!", "Great Job!", "Fantastic!", "You Rock!"];
const phrasesWrong = ["Try Again!", "Don't Give Up!", "Keep Going!", "Nice Try!", "Almost There!", "You Can Do It!"];

let isGameRunning = false;
let score = 0;
let cards = [];
let particles = [];
let saberTrail = [];
let snowFlakes = []; 
let synth = window.speechSynthesis;
let currentTargetWord = "";

const SPEECH_RATE = 0.85; 

// é¼“å‹µç‰¹æ•ˆè®Šæ•¸
let feedback = { text: "", life: 0, y: 0, scale: 1 };

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);
  rectMode(CENTER);
  
  // èƒŒæ™¯é›ªèŠ±
  for(let i=0; i<60; i++) {
    snowFlakes.push({
      x: random(width), y: random(height),
      size: random(2, 6), speed: random(0.5, 2.5)
    });
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function startGame() {
  document.getElementById('start-overlay').classList.add('hidden');
  if(synth) synth.speak(new SpeechSynthesisUtterance("")); 
  isGameRunning = true;
  score = 0;
  setTimeout(startRound, 800);
}

function startRound() {
  if(!isGameRunning) return;

  let targetData = random(gameData);
  currentTargetWord = targetData.word;
  
  let distractorData;
  do { distractorData = random(gameData); } while(distractorData.word === targetData.word);

  let hint = document.getElementById('listen-hint');
  hint.classList.add('show');
  hint.innerText = "ğŸ”Š Listen...";

  speak(targetData.word, null, SPEECH_RATE);

  setTimeout(() => {
    hint.classList.remove('show');
    spawnCards(targetData, distractorData);
  }, 1000); 
}

function spawnCards(target, distractor) {
  let items = [target, distractor];
  if (random() > 0.5) items.reverse();

  let startLeft = { x: width * 0.15, y: height + 50 };
  let startRight = { x: width * 0.85, y: height + 50 };
  let targetLeft = { x: width * 0.4, y: height * 0.2 };
  let targetRight = { x: width * 0.6, y: height * 0.2 };

  launchCard(startLeft.x, startLeft.y, targetLeft.x, targetLeft.y, items[0], items[0].word === currentTargetWord);
  launchCard(startRight.x, startRight.y, targetRight.x, targetRight.y, items[1], items[1].word === currentTargetWord);
}

function launchCard(startX, startY, destX, destY, data, isTarget) {
    let gravity = 0.12; 
    let heightDiff = startY - destY;
    let vy = -Math.sqrt(2 * gravity * heightDiff); 
    let timeToPeak = Math.abs(vy / gravity);
    let vx = (destX - startX) / timeToPeak;

    cards.push({
        x: startX, y: startY,
        vx: vx, vy: vy,
        gravity: gravity,
        size: 150,
        angle: 0, rotSpeed: random(-0.01, 0.01), 
        data: data, isTarget: isTarget,
        draw: function() {
            push();
            translate(this.x, this.y); rotate(this.angle);
            fill(255); 
            stroke(isTarget ? "#c0392b" : "#2c3e50"); 
            strokeWeight(5);
            rect(0, 0, this.size, this.size * 1.3, 20);
            textSize(90); noStroke(); text(this.data.icon, 0, -20);
            fill(0); textSize(30); textStyle(BOLD); text(this.data.word, 0, 55);
            pop();
        },
        update: function() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += this.gravity;
            this.angle += this.rotSpeed;
        }
    });
}

function draw() {
  setGradient(0, 0, width, height, color(11, 30, 16), color(5, 10, 5));
  drawSnow();
  drawChristmasBorder();

  if(!isGameRunning) return;

  // 1. å…‰åŠæ›´æ–° (æ»‘é¼ æ§åˆ¶)
  updateSaber(mouseX, mouseY);
  drawSaberOptimized();

  // 2. å¡ç‰‡é‚è¼¯
  for (let i = cards.length - 1; i >= 0; i--) {
    let c = cards[i];
    if (!c) continue; 
    c.update();
    c.draw();

    if (dist(mouseX, mouseY, c.x, c.y) < c.size/2 + 30) {
        handleHit(c, i);
        break; 
    } 
    else if (c.y > height + 200) {
      cards.splice(i, 1);
      if(cards.length === 0) setTimeout(startRound, 1000);
    }
  }

  // 3. ç²’å­ç‰¹æ•ˆ
  drawParticles();
  
  // 4. æ–‡å­—å›é¥‹
  drawFeedback();

  // 5. åˆ†æ•¸
  fill(255); textSize(36); textStyle(BOLD); noStroke();
  textAlign(LEFT, TOP);
  text("Score: " + score, 60, 60);
  textAlign(CENTER, CENTER);
}

// --- å…¨æ–°å‡ç´šçš„ç²’å­ç³»çµ± ---
function createExplosion(x, y, colorHex) {
  // 1. ç”¢ç”Ÿå¡ç‰‡é¡è‰²çš„ç¢å±‘ (Confetti)
  for (let i = 0; i < 30; i++) {
    particles.push(new Particle(x, y, colorHex, 'debris'));
  }
  // 2. ç”¢ç”Ÿé‡‘è‰²çš„é­”æ³•ç«èŠ± (Sparkle)
  for (let i = 0; i < 20; i++) {
    particles.push(new Particle(x, y, '#ffd700', 'sparkle'));
  }
}

class Particle {
    constructor(x, y, col, type) {
        this.x = x;
        this.y = y;
        this.col = col;
        this.type = type;
        
        let angle = random(TWO_PI);
        let speed = random(2, 12); // çˆ†ç‚¸é€Ÿåº¦æ›´å¿«
        this.vx = cos(angle) * speed;
        this.vy = sin(angle) * speed;
        
        this.life = 255;
        this.gravity = 0.4; // é‡åŠ›æ„Ÿ
        this.friction = 0.94; // ç©ºæ°£é˜»åŠ›
        
        this.size = type === 'debris' ? random(8, 16) : random(3, 8);
        this.rot = random(TWO_PI);
        this.rotSpeed = random(-0.3, 0.3);
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity;
        this.vx *= this.friction;
        this.vy *= this.friction;
        
        this.life -= this.type === 'debris' ? 5 : 8; // ç¢å±‘æ¶ˆå¤±æ…¢ï¼Œç«èŠ±æ¶ˆå¤±å¿«
        this.rot += this.rotSpeed;
        this.size *= 0.96; // æ…¢æ…¢ç¸®å°
    }
    
    draw() {
        push();
        translate(this.x, this.y);
        rotate(this.rot);
        noStroke();
        
        // è¨­å®šé¡è‰²
        let c = color(this.col);
        c.setAlpha(this.life);
        fill(c);

        if (this.type === 'debris') {
            // ç¢å±‘æ˜¯æ–¹å½¢çš„
            rect(0, 0, this.size, this.size);
        } else {
            // ç«èŠ±æ˜¯ç™¼å…‰çš„
            blendMode(ADD);
            circle(0, 0, this.size);
            blendMode(BLEND);
        }
        pop();
    }
}

function drawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.update();
    p.draw();
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// --- é¼“å‹µèªç‰¹æ•ˆ ---
function triggerFeedback(isCorrect) {
    if (isCorrect) {
        feedback.text = random(phrasesCorrect);
    } else {
        feedback.text = random(phrasesWrong);
    }
    feedback.life = 255;
    feedback.y = height / 2;
    feedback.scale = 0.5;
}

function drawFeedback() {
    if (feedback.life > 0) {
        push();
        translate(width / 2, feedback.y);
        scale(feedback.scale);
        
        let goldColor = color(255, 215, 0, feedback.life);
        drawingContext.shadowBlur = 40; // å…‰æšˆæ›´å¼·
        drawingContext.shadowColor = 'rgba(255, 215, 0, 0.8)';
        
        fill(goldColor);
        stroke(255, feedback.life);
        strokeWeight(3);
        
        textSize(90);
        textStyle(BOLD);
        text(feedback.text, 0, 0);
        
        feedback.life -= 4;
        feedback.y -= 1.5; // ä¸Šå‡é€Ÿåº¦
        if(feedback.scale < 1.2) feedback.scale += 0.05;
        
        drawingContext.shadowBlur = 0;
        pop();
    }
}

function handleHit(card, index) {
  cards.splice(index, 1);
  // è§¸ç™¼å¤§çˆ†ç‚¸ç‰¹æ•ˆ
  createExplosion(card.x, card.y, card.data.color);

  if (card.isTarget) {
    score += 10;
    triggerFeedback(true);
    speak(feedback.text, null, SPEECH_RATE);
    cards = []; 
    setTimeout(startRound, 1200);
  } else {
    triggerFeedback(false);
    speak(feedback.text, null, SPEECH_RATE);
    cards = [];
    setTimeout(startRound, 1200);
  }
}

function drawChristmasBorder() {
  push();
  rectMode(CORNER); 
  noStroke();
  let borderW = 30; 
  let stripeLen = 40; 
  let redC = color('#c0392b');
  let greenC = color('#27ae60');

  for(let x = 0; x < width; x += stripeLen) {
    fill((x / stripeLen) % 2 === 0 ? redC : greenC);
    rect(x, 0, stripeLen, borderW);
  }
  for(let x = 0; x < width; x += stripeLen) {
    fill((x / stripeLen) % 2 !== 0 ? redC : greenC); 
    rect(x, height - borderW, stripeLen, borderW);
  }
  for(let y = borderW; y < height - borderW; y += stripeLen) {
    fill((y / stripeLen) % 2 === 0 ? redC : greenC);
    rect(0, y, borderW, stripeLen);
  }
  for(let y = borderW; y < height - borderW; y += stripeLen) {
    fill((y / stripeLen) % 2 !== 0 ? redC : greenC); 
    rect(width - borderW, y, borderW, stripeLen);
  }

  fill(redC); rect(0,0,borderW,borderW);
  fill(greenC); rect(width-borderW,0,borderW,borderW);
  fill(greenC); rect(0,height-borderW,borderW,borderW);
  fill(redC); rect(width-borderW,height-borderW,borderW,borderW);
  pop();
}

function updateSaber(x, y) {
  saberTrail.push({x: x, y: y, life: 8});
  for (let i = saberTrail.length - 1; i >= 0; i--) {
    saberTrail[i].life--;
    if (saberTrail[i].life <= 0) saberTrail.splice(i, 1);
  }
}

function drawSaberOptimized() {
  if (saberTrail.length < 2) return;
  blendMode(ADD); 
  noFill(); strokeCap(ROUND); strokeJoin(ROUND);

  stroke(255, 0, 0, 100); strokeWeight(25);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();

  stroke(255, 50, 50, 200); strokeWeight(15);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();

  stroke(255, 255, 255, 255); strokeWeight(5);
  beginShape(); for (let p of saberTrail) vertex(p.x, p.y); endShape();
  blendMode(BLEND); 
}

function drawSnow() {
  fill(255, 100); noStroke();
  for(let s of snowFlakes) {
    circle(s.x, s.y, s.size);
    s.y += s.speed;
    if(s.y > height) s.y = -10;
  }
}

function setGradient(x, y, w, h, c1, c2) {
  noFill();
  for (let i = y; i <= y + h; i+=10) { 
    let inter = map(i, y, y + h, 0, 1);
    let c = lerpColor(c1, c2, inter);
    stroke(c); strokeWeight(10);
    line(x, i, x + w, i);
  }
}

function speak(text, callback, rate = 1.0) {
  synth.cancel();
  let u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US'; 
  u.rate = rate; 
  if(callback) u.onend = callback;
  synth.speak(u);
}
</script>
</body>
</html>
