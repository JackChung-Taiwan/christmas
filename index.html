<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Safe Height AR Ninja</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Varela+Round&display=swap" rel="stylesheet">

  <style>
    body {
      margin: 0;
      background-color: #000;
      color: #fff;
      font-family: 'Varela Round', system-ui, sans-serif;
      overflow: hidden;
      user-select: none;
    }

    /* é¡åƒç¿»è½‰ */
    .input_video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); 
    }
    .input_video { z-index: 0; }
    canvas { z-index: 1; }

    /* UI */
    #ui-layer {
      position: absolute;
      inset: 0;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
      background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.6) 100%);
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
    }

    .stat-box {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 10px 25px;
      border-radius: 50px;
      text-align: center;
      backdrop-filter: blur(4px);
    }

    .stat-label { font-size: 14px; opacity: 0.8; margin-bottom: 2px; }
    .stat-value { font-family: 'Fredoka One'; font-size: 32px; text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
    #lives { color: #ff4757; }

    #target-container {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    #target-box {
      background: rgba(0, 0, 0, 0.6);
      border: 3px solid #ffd700;
      border-radius: 24px;
      padding: 15px 50px;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      transition: transform 0.1s;
    }

    #target-label { font-size: 14px; color: #ffd700; font-weight: bold; letter-spacing: 2px; }
    #target-word { font-family: 'Fredoka One'; font-size: 50px; line-height: 1; margin-top: 5px; }

    #status-text {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Fredoka One';
      font-size: 90px;
      text-shadow: 4px 4px 0 rgba(0,0,0,0.8);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s;
      z-index: 20;
    }

    .modal-screen {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 50;
      pointer-events: auto;
      text-align: center;
      transition: opacity 0.5s;
    }

    .btn {
      background: #e17055;
      color: #fff;
      border: none;
      padding: 15px 50px;
      font-size: 24px;
      font-family: 'Fredoka One';
      border-radius: 50px;
      cursor: pointer;
      margin-top: 20px;
    }
    .btn:hover { transform: scale(1.05); background: #ff7675; }
  </style>
</head>
<body>

<div id="game-container">
    <video class="input_video" playsinline muted autoplay></video>
    <canvas class="output_canvas"></canvas>
    
    <div id="status-text">MISSED!</div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="stat-box">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Lives</div>
                <div class="stat-value" id="lives">â¤ï¸â¤ï¸â¤ï¸</div>
            </div>
        </div>
        
        <div id="target-container">
            <div id="target-box">
                <div id="target-label">SLICE THIS</div>
                <div id="target-word">Wait...</div>
            </div>
        </div>
    </div>

    <div id="start-screen" class="modal-screen">
        <h1 style="font-family:'Fredoka One'; font-size:50px; color:#ffd700;">Safe Height Ninja</h1>
        <p style="color:#ccc; font-size:18px; line-height: 1.6;">
            1. å¡ç‰‡æœƒæ…¢æ…¢é£„<br>
            2. <b>çµ•å°ä¸æœƒ</b>é£›å‡ºè¢å¹•ä¸Šé¢<br>
            3. æ‰è½å¾Œè‡ªå‹•ä¸‹ä¸€é¡Œ
        </p>
        <button class="btn" onclick="startGame()">é–‹å•Ÿé¡é ­ & é–‹å§‹</button>
    </div>

    <div id="game-over-screen" class="modal-screen" style="display: none; opacity: 0;">
        <h1 style="color: #fff;">GAME OVER</h1>
        <div style="font-family: 'Fredoka One'; font-size: 60px; color: #ffd700; margin: 20px;" id="final-score">0</div>
        <button class="btn" onclick="resetGame()">å†ç©ä¸€æ¬¡</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    const canvas = document.querySelector('.output_canvas');
    const ctx = canvas.getContext('2d');
    const videoElement = document.querySelector('.input_video');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const targetWordEl = document.getElementById('target-word');
    const targetBoxEl = document.getElementById('target-box');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const statusTextEl = document.getElementById('status-text');

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.scale(dpr, dpr);
        window.W = window.innerWidth;
        window.H = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const VOCAB_DB = [
        { word: 'SANTA', icon: 'ğŸ…', color: '#ff7675' },
        { word: 'TREE', icon: 'ğŸ„', color: '#55efc4' },
        { word: 'GIFT', icon: 'ğŸ', color: '#ffeaa7' },
        { word: 'STAR', icon: 'â­', color: '#fdcb6e' },
        { word: 'SNOW', icon: 'â„ï¸', color: '#74b9ff' },
        { word: 'BELL', icon: 'ğŸ””', color: '#fab1a0' },
        { word: 'SOCK', icon: 'ğŸ§¦', color: '#ffcccc' },
        { word: 'DEER', icon: 'ğŸ¦Œ', color: '#e17055' },
        { word: 'ELF', icon: 'ğŸ§', color: '#00b894' },
        { word: 'CAKE', icon: 'ğŸ‚', color: '#fd79a8' }
    ];

    // --- ç‰©ç†åƒæ•¸ ---
    const GRAVITY = 0.07;        // æ…¢é€Ÿé‡åŠ›
    const AIR_RESISTANCE = 0.99; // ç©ºæ°£é˜»åŠ›
    
    let gameState = {
        isPlaying: false,
        score: 0,
        lives: 3,
        targetWord: null,
        objects: [],
        particles: [],
        slices: [], 
        hand: { x: -100, y: -100, prevX: -100, prevY: -100, speed: 0 },
        isWaveActive: false,
        waitingForNextWave: false
    };

    let frameCount = 0;

    function showStatus(text, color) {
        statusTextEl.innerText = text;
        statusTextEl.style.color = color;
        statusTextEl.style.opacity = 1;
        setTimeout(() => { statusTextEl.style.opacity = 0; }, 800);
    }

    class GameObject {
        constructor(data, laneIndex) {
            this.active = true;
            this.radius = 110; 
            
            // é›™è»Œé“: 0(å·¦), 1(å³)
            let laneWidth = window.W / 2;
            let startX = laneWidth * laneIndex + (laneWidth / 2);

            this.x = startX + (Math.random() - 0.5) * 50; 
            this.y = window.H + 150; 
            
            // --- ç²¾æº–é«˜åº¦è¨ˆç®— (Physics Calculation) ---
            
            // 1. è¨­å®šã€Œå¤©èŠ±æ¿ã€ï¼šè¢å¹•é«˜åº¦çš„ 15% è™• (ä¿ç•™é ‚éƒ¨ç©ºé–“)
            // å¡ç‰‡æœ€é«˜åªæœƒé£›åˆ°é€™è£¡ï¼Œçµ•å°ä¸æœƒè¶…é
            let safeCeiling = window.H * 0.15;
            
            // 2. è¨­å®šã€Œéš¨æ©Ÿé«˜åº¦å€é–“ã€ï¼šè®“å¡ç‰‡åœ¨ 15% ~ 35% ä¹‹é–“çš„é«˜ç©ºéš¨æ©Ÿåœæ»¯
            // é€™æ¨£è¦–è¦ºä¸Šæ¯”è¼ƒè‡ªç„¶ï¼Œä¸æœƒæ¯æ¬¡éƒ½åœåœ¨åŒä¸€æ¢ç·šä¸Š
            let randomPeakY = safeCeiling + Math.random() * (window.H * 0.2);
            
            // 3. è¨ˆç®—éœ€è¦ä¸Šå‡çš„è·é›¢ (ä½ç§»)
            let distanceToTravel = this.y - randomPeakY;
            
            // 4. åæ¨åˆé€Ÿåº¦å…¬å¼ï¼šv = sqrt(2 * g * h)
            // é€™ä¿è­‰äº†åˆå§‹é€Ÿåº¦å‰›å¥½èƒ½è®“å¡ç‰‡é£›åˆ° randomPeakY å°±åœä½(é€Ÿåº¦æ­¸é›¶)ï¼Œç„¶å¾Œé–‹å§‹ä¸‹å¢œ
            let requiredLaunchSpeed = Math.sqrt(2 * GRAVITY * distanceToTravel);

            // æ‡‰ç”¨é€Ÿåº¦
            this.vy = -requiredLaunchSpeed;
            
            // Xè»¸ï¼šç¨å¾®å¾€ä¸­é–“é£„
            let drift = (startX < window.W / 2) ? 0.8 : -0.8; 
            this.vx = drift + (Math.random() - 0.5) * 0.3;
            
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.03; 

            this.icon = data.icon;
            this.word = data.word;
            this.color = data.color;
            this.isTarget = (this.word === gameState.targetWord);
        }

        update() {
            // 1. æ‡‰ç”¨ç‰©ç†
            this.x += this.vx;
            this.y += this.vy;
            
            this.vy += GRAVITY;       // é‡åŠ›
            this.vx *= AIR_RESISTANCE; // é˜»åŠ›
            
            this.rotation += this.rotationSpeed;
            
            // 2. é‚Šç•Œèˆ‡ç‹€æ…‹æª¢æŸ¥
            if (this.y > window.H + 200) {
                this.active = false;
                
                if (this.isTarget && gameState.isPlaying) {
                    handleMiss();
                }
            }
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            const w = 220; const h = 280; const r = 20;

            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 25;
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.roundRect(-w/2, -h/2, w, h, r); ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.roundRect(-w/2 + 15, -h/2 + 15, w - 30, w - 30 - 60, r-5); ctx.fill();
            
            ctx.font = "120px 'Segoe UI Emoji'";
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(this.icon, 0, -30);
            
            ctx.fillStyle = "#2d3436";
            ctx.font = "900 36px 'Fredoka One', sans-serif";
            ctx.fillText(this.word, 0, 95);
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color, isText = false, text = '') {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10;
            this.life = 1.0;
            this.color = color;
            this.isText = isText;
            this.text = text;
            this.scale = 1;
        }
        update() {
            this.x += this.vx; this.y += this.vy; this.vy += 0.1; this.life -= 0.02;
            if(this.isText) this.scale += 0.02;
        }
        draw() {
            ctx.save(); ctx.globalAlpha = Math.max(0, this.life);
            if (this.isText) {
                ctx.translate(this.x, this.y); ctx.scale(this.scale, this.scale);
                ctx.font = "900 60px 'Fredoka One'"; ctx.fillStyle = this.color; 
                ctx.strokeStyle = "white"; ctx.lineWidth = 4;
                ctx.strokeText(this.text, 0, 0); ctx.fillText(this.text, 0, 0);
            } else {
                ctx.fillStyle = this.color; 
                ctx.beginPath(); ctx.arc(this.x, this.y, 8 * this.life, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        }
    }

    function initGame() {
        startScreen.style.opacity = 0;
        setTimeout(() => startScreen.style.display = "none", 300);
        gameOverScreen.style.display = "none";
        gameOverScreen.style.opacity = 0;

        gameState.score = 0;
        gameState.lives = 3;
        gameState.objects = [];
        gameState.particles = [];
        gameState.isPlaying = true;
        gameState.isWaveActive = false;
        gameState.waitingForNextWave = false;
        updateUI();
        startNewWave();
        
        if (!cameraStarted) { camera.start(); cameraStarted = true; }
    }

    function startNewWave() {
        if (!gameState.isPlaying) return;
        gameState.isWaveActive = true;
        gameState.waitingForNextWave = false;

        const targetData = VOCAB_DB[Math.floor(Math.random() * VOCAB_DB.length)];
        gameState.targetWord = targetData.word;

        targetWordEl.innerText = gameState.targetWord;
        targetBoxEl.style.transform = "scale(1.2)";
        setTimeout(() => targetBoxEl.style.transform = "scale(1)", 200);

        setTimeout(() => { if(gameState.isPlaying) spawnCards(targetData); }, 1200);
    }

    function spawnCards(targetData) {
        let wrongData;
        do { wrongData = VOCAB_DB[Math.floor(Math.random() * VOCAB_DB.length)]; } 
        while (wrongData.word === gameState.targetWord);

        let cards = [targetData, wrongData];
        if (Math.random() < 0.5) cards = [wrongData, targetData];

        gameState.objects.push(new GameObject(cards[0], 0));
        gameState.objects.push(new GameObject(cards[1], 1));
    }

    function handleMiss() {
        showStatus("MISSED", "#e17055");
        gameState.lives--;
        updateUI();
        if (gameState.lives <= 0) endGame();
    }

    function clearRemainingCards() {
        gameState.objects.forEach(obj => {
            if (obj.active) {
                // è®“å‰©ä¸‹çš„å¡ç‰‡å¾€ä¸‹æ‰
                obj.vy = 5; 
                obj.vx *= 0.5;
                obj.active = false; // è¦–è¦ºä¿ç•™ä½†ä¸å¯äº’å‹•
            }
        });
    }

    function gameLoop() {
        ctx.clearRect(0, 0, window.W, window.H);
        frameCount++;

        if (gameState.isPlaying) {
            
            // æª¢æŸ¥æ¸…å ´
            let activeCount = 0;
            gameState.objects.forEach(o => { 
                if (o.y < window.H + 200) activeCount++;
            });
            
            if (gameState.isWaveActive && activeCount === 0 && !gameState.waitingForNextWave) {
                gameState.waitingForNextWave = true;
                setTimeout(startNewWave, 1000);
            }

            for (let i = gameState.objects.length - 1; i >= 0; i--) {
                let obj = gameState.objects[i];
                obj.update();
                obj.draw();

                if (!obj.active) {
                    if(obj.y > window.H + 200) {
                        gameState.objects.splice(i, 1);
                    }
                    continue;
                }

                // åˆ‡å‰²åˆ¤å®š
                let dx = gameState.hand.x - obj.x;
                let dy = gameState.hand.y - obj.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < obj.radius && gameState.hand.speed > 3) {
                    if (obj.word === gameState.targetWord) {
                        gameState.score += 10;
                        createSliceEffect(obj, true);
                        showStatus("NICE!", "#2ecc71");
                        
                        obj.active = false; 
                        obj.vy = -5; // åˆ‡å°äº†å¾€ä¸Šé£›
                        
                        clearRemainingCards();
                        updateUI();
                    } else {
                        showStatus("WRONG", "#d63031");
                        gameState.lives--;
                        createSliceEffect(obj, false);
                        
                        obj.active = false;
                        obj.vy = 5; // åˆ‡éŒ¯å¾€ä¸‹æ‰
                        
                        updateUI();
                        if (gameState.lives <= 0) endGame();
                    }
                }
            }
        }

        for (let i = gameState.particles.length - 1; i >= 0; i--) {
            let p = gameState.particles[i];
            p.update();
            p.draw();
            if (p.life <= 0) gameState.particles.splice(i, 1);
        }

        drawBlade();
        requestAnimationFrame(gameLoop);
    }

    function createSliceEffect(obj, isCorrect) {
        let color = isCorrect ? "#2ecc71" : "#d63031"; 
        let msg = isCorrect ? "+10" : "-1 â¤";
        for (let i = 0; i < 15; i++) gameState.particles.push(new Particle(obj.x, obj.y, obj.color));
        gameState.particles.push(new Particle(obj.x, obj.y, color, true, msg));
    }

    function drawBlade() {
        if (gameState.slices.length < 2) return;
        ctx.shadowBlur = 15; ctx.shadowColor = "#00ffff";
        ctx.beginPath();
        ctx.moveTo(gameState.slices[0].x, gameState.slices[0].y);
        for (let i = 1; i < gameState.slices.length; i++) ctx.lineTo(gameState.slices[i].x, gameState.slices[i].y);
        ctx.strokeStyle = "#fff"; ctx.lineWidth = 8; ctx.lineCap = "round"; ctx.lineJoin = "round"; ctx.stroke();
        ctx.shadowBlur = 0;
        if (gameState.slices.length > 8) gameState.slices.shift();
    }

    function updateUI() {
        scoreEl.innerText = gameState.score;
        let livesStr = ""; for(let i=0; i<gameState.lives; i++) livesStr += "â¤ï¸";
        livesEl.innerHTML = livesStr;
    }

    function endGame() {
        gameState.isPlaying = false;
        document.getElementById('final-score').innerText = gameState.score;
        gameOverScreen.style.display = "flex";
        setTimeout(() => gameOverScreen.style.opacity = 1, 10);
    }

    window.startGame = initGame;
    window.resetGame = initGame;

    let cameraStarted = false;
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    
    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const x = landmarks[8].x * window.W;
            const y = landmarks[8].y * window.H;
            const dx = x - gameState.hand.prevX;
            const dy = y - gameState.hand.prevY;
            gameState.hand.speed = Math.sqrt(dx*dx + dy*dy);
            gameState.hand.prevX = gameState.hand.x;
            gameState.hand.prevY = gameState.hand.y;
            gameState.hand.x = x;
            gameState.hand.y = y;
            gameState.slices.push({x: x, y: y});
        } else {
            gameState.hand.speed = 0;
            if(gameState.slices.length > 0) gameState.slices.shift(); 
        }
    });

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280,
        height: 720
    });
    
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
